G := 80.0;
balls := [];
ball_rad := 6.0;
last_mx := 0;
last_my := 0;
sl_force := 1.0;
mpos := {
	.x = 0.0,
	.y = 0.0
};

init_window(800, 600, "Gravisim");
clear_background(DARK_GRAY);

while !window_should_close() {
	begin_drawing();
	clear_background(DARK_GRAY);
	dt := get_frame_time();
	mx := get_mouse_x();
	my := get_mouse_y();

	if is_mouse_button_down(MOUSE_LEFT) {
		mpos.x += get_mouse_dx();
		mpos.y += get_mouse_dy();
	}
	
	if is_mouse_button_pressed(MOUSE_RIGHT) {
		last_mx = mx;
		last_my = my;
	} else if is_mouse_button_released(MOUSE_RIGHT) {
		append(balls, {
			.pos: {
				.x: float(mx) - mpos.x,
				.y: float(my) - mpos.y,
			},
			.vel: {
				.x: (mx - last_mx) * sl_force,
				.y: (my - last_my) * sl_force,
			},
		});
	} 

	for iter := 0; iter < 3; iter+=1 {
		for i := 0; i < len(balls); i+=1 {
			for j := i + 1; j < len(balls); j+=1 {
				dx := balls[i].pos.x - balls[j].pos.x;
				dy := balls[i].pos.y - balls[j].pos.y;
				D := sqrt(dx * dx + dy * dy);
				if D < 3 -> D = 3;

				balls[i].vel.x -= G * dx / (D * D) * dt;
				balls[i].vel.y -= G * dy / (D * D) * dt;
				balls[j].vel.x += G * dx / (D * D) * dt;
				balls[j].vel.y += G * dy / (D * D) * dt;
			}	
		}

		for ball in balls {
			ball.pos.x += ball.vel.x * dt;
			ball.pos.y += ball.vel.y * dt;
		}
	}

	for ball in balls {
		draw_ellipse(
			int(ball.pos.x + mpos.x),
			int(ball.pos.y + mpos.y),
			ball_rad, ball_rad,
			RED);
	}

	end_drawing();
}

close_window();
